# Network

## 브라우저의 렌더링 동작과정

1. 유저가 웹 브라우저에 URL을 입력한다.
2. URL로 지정한 웹 서버에게 HTTP 요청을 송신한다.
3. 웹 서버가 요청을 해석한다.
4. 웹 서버가 요청받은 파일을 웹 브라우저에 돌려보낸다.
5. 웹 브라우저가 수신한 데이터를 해석해서 표시한다.

#### 네트워크 관점

1. 웹 브라우저가 HTTP 메시지 생성
2. SOCKET 라이브러리를 통해 전달
   - TCP/IP 연결(IP, PORT
   - 데이터 전달(HTTP 메시지)
3. TCP/IP 패킷 생성, HTTP 메시지 포함

![image](https://user-images.githubusercontent.com/68647194/105580338-1fea6300-5dcf-11eb-9696-b1c6d00deaf1.png)

## URL(Uniform Resource Locator)

- URI(Uniform Resource Identifier) = URL(Locator) + URN(Name)
- **인터넷상의 `데이터 위치`를 가리키는 표준적인 표기법**
- 스킴://호스트명/패스 ex) `http://www.n-study.com/network/index.html`
- `www.n-study.com` 이라는 웹 서버가 디렉토리 network 내의 index.html을 HTTP로 전송하도록 요청하는 내용
- 호스트명 뒤 포트번호가 생략된 경우에는 HTTP의 잘 알려진 포트인 TCP `80번`으로 연결

## HTTP(Hyper Text Transfer Protocol)

- **웹 서버에 존재하는 HTML 파일이나 이미지 파일을 PC의 `웹 브라우저로 전송`하기 위한 `프로토콜`**
- 클라이언트 서버 구조

  - HTTP 프로토콜을 사용한 파일 전송은 `HTTP 요청`과 `HTTP 응답`을 주고받음으로써 이루어진다.
  - HTTP 요청 (요청 행, 메시지 헤더, 빈행, 엔티티 바디)
  - 요청 행: 메소드
  - 헤더 : Host 필수
  - HTTP 응답 (상태 행, 메시지 헤더, 빈행, 엔티티 바디)
  - 상태 행: 상태 코드

  ![image](https://user-images.githubusercontent.com/68647194/105581206-d8fe6c80-5dd2-11eb-9339-124b9b6251e7.png)

- 무상태 프로토콜(Stateless)
  - 서버가 클라이언트의 상태를 보존X
  - 장점 : 서버 확장성이 높다.
  - 단점 : 클라이언트가 추가 데이터 전송
- 비 연결성

  - HTTP는 기본이 연결을 유지하지 않는 모델
  - 서버 자원을 매우 효율적으로 사용할 수 있다.
  - 단점 : TCP/IP 연결을 새로 맞어야함 - 3 way handshake 시간 추가
  - 지금은 HTTP 지속 연결로 문제 해결

  ![image](https://user-images.githubusercontent.com/68647194/105580901-89b83c00-5dd2-11eb-8e2e-a0bd889282ba.png)

- HTTP/1.1(1997) : 가장 많이 사용, 우리에게 가장 중요한 버전
- HTTP/2(2015) : 성능 개선
- HTTP/3(진행중) : TCP 대신에 UDP 사용, 성능 개선

### 주요 HTTP 메소드

- GET: URI로 지정한 데이터를 `가져온다.`
  - 리소스 조회
  - 서버에 전달하고 싶은 데이터는 query를 통해서 전달
  - 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음
- POST: URI로 지정한 서버의 커맨드에 대해 데이터를 `송신한다.`
  - 요청 데이터 처리
  - 메시지 바디를 통해 서버로 요청 데이터 전달
  - 서버는 요청 데이터를 처리
  - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
  - 서버가 아직 식별하지 않은 새 리소스 생성
  - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우 ex) 주문에서 결제완료 -> 배달시작 -> 배달완료
- PUT: URI로 지정한 데이터를 전송한 데이터로 `덮어쓴다.`
  - **클라이언트가 리소스를 식별**
  - 클라이언트가 리소스 위치를 알고 URI 지정
- PATCH: 리소스 부분 변경
- DELETE: 리소스 제거

### 주요 HTTP 상태 코드

- 1XX: 정보 - 요청이 수신되어 처리중
- 2XX: 성공 - 서버가 요청을 성공적으로 처리했다는 것을 알린다.
- 3XX: 리다이렉트 - 요청을 완료하려면 추가 행동이 필요
- 4XX: 클라이언트 에러 - 요청에 문제가 있어 처리하지 못했다는 것을 알린다.
- 5XX: 서버 에러 - 서버 쪽에 문제가 있어 처리하지 못했다는 것을 알린다.

#### 3XX 추가 내용

- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(자동 리다이렉트)
- 302 Found : Post/Redirect/Get(PRG)
  ex) POST로 주문후에 웹 브라우저를 새로고침하면? -> 새로고침은 다시 요청 -> 중복 주문이 될 수 있다.
  - POST로 주문후에 새로 고침으로 인한 중복 주문 방지
  - POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트
- 304 Not Modified : 캐시를 목적으로 사용

## 포트 번호

- 포트 번호는 PC나 서버상에서 동작하는 **애플리케이션** 그 자체를 식별하기 위한 정보
- 같은 IP내에서 **프로세스** 구분
- `포트 번호를 기반`으로 애플리케이션 데이터를 분배하는 역할을 하는 프로토콜이 `TCP`와 `UDP` 이다.
- 잘 알려진 포트
  - TELNET (23)
  - HTTP (80)
  - HTTPS (443)

## IP

- 인터넷 프로토콜
- 지정한 IP 주소에 데이터 전달
- 패킷이라는 통신 단위로 데이터 전달

### IP 프로토콜의 한계

- 비연결성
  - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성
  - 중간에 패킷이 사라지면?
  - 패킷이 순서대로 안오면?
- 프로그램 구분
  - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

## TCP

- **애플리케이션 간의 데이터 전달에 사용되는 프로토콜**
- TCP에는 애플리케이션 간의 데이터 전달 외에도 데이터를 분할하는 기능이 있다.
- MSS(Maximum Segment Size)를 넘을 경우 TCP에서 데이터를 여러개로 분할
- TCP 헤더를 추가한 애플리케이션 데이터를 TCP 세그먼트라고 부른다.
  ex) IP헤더 + TCP헤더 + HTTP헤더
- 연결 지향 (TCP 3 way handshake)
- 데이터 전달 보증
- 순서 보장
- 신뢰성 있는 프로토콜
- 현재는 대부분 TCP 사용

## Three-way handshake

- 말 그대로 데이터 전송을 수행하는 애플리케이션끼리 '인사를 3번 함'으로써 연결을 성립하는 것을 말한다.
- 애플리케이션 간에 신뢰성 있는 데이터 전송 수행<br>
  ex) [연결] 연결해도 될까요? -> 네. 이쪽에서도 연결하겠습니다 -> 알겠습니다<br>
  ex) [종료] 연결을 종료해도 될까요? -> 네. 괜찮습니다 -> 이쪽에서도 연결을 종료하겠습니다 -> 네. 알겠습니다

  ![image](https://user-images.githubusercontent.com/68647194/105580398-7d7eaf80-5dcf-11eb-9744-8baaeec4e272.png)

## UDP

- 신뢰성이 낮더라도 어찌 됐든 빠르게 데이터를 전송하는 것이 우선
- UDP 헤더를 추가한 애플리케이션 데이터를 UDP 데이터그램이라고 부른다.
- UDP 용도
  - 실시간 데이터를 전송할 때
  - 여러 상대에게 같은 내용의 데이터를 전송할 때
  - 데이터 전송 시 신뢰성이 필요하지 않은 소량의 데이터를 전송할 때
- 하얀 도화지에 비유(기능이 거의 없음)
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름<br>
  (연결지향X - TCP 3 way handshake, 데이터 전달 보증X, 순서 보장X)
- IP와 거의 같다. +PORT, +체크섬 정도만 추가
- 애플리케이션에서 추가 작업 필요

## 포트포워딩

- 포트를 개방함으로써 인터넷 쪽에서 먼저 통신을 시작하여 홈 네트워크 내부의 특정 PC에게 패킷을 보낼 수 있다.
- 인터넷 쪽에서 시작된 통신의 목적지 IP는 브로드밴드 라우터의 공인 IP로 지정된다.
- 브로드밴드 라우터는 이 목적지 IP 주소를 네트워크 내부의 특정 IP주소로 다시 변환하여 전송해준다.
- 홈 네트워크로부터 인터넷 쪽으로 향하는 통신의 경우 송신지의 IP 주소가 브로드밴드 라우터의 공인 IP 주소로 변환된다.

## DNS

- IP는 기억하기 어렵다.
- IP는 변경될 수 있다.
- DNS : 도메인 네임 시스템
- 도메인 명을 IP 주소로 변환한다.

## DNS 라운드 로빈 방식의 통신 플로우

- 서버 어려 대를 효율적으로 운용하기 위해서 부하를 분산한다.
- `부하분산 방식` 중에서 가장 간단한 것이 `라운드 로빈`
- 같은 호스트명에 대한 A 레코드가 여러 개 있다면, DNS 서버는 등록된 IP주소를 라운드 로빈(순서대로)으로 반환한다.

### 문제점

- 효율적으로 부하를 분산할 수 없다.
  - 서버의 실질적인 부하를 고려하지 않고 DNS 요청에 순서대로 A레코드의 IP 주소를 반환할 뿐이므로 서버의 부하가 편향되는 경우가 생긴다.
- 서버 장애를 감지할 수 없다.

### 해결 방법

- 로드밸런서라고 불리는 전용 부하분산 장비가 존재한다.
- 로드밸런서를 도입하면 서버의 부하나 장애를 고려하여 유연하게 부하를 분산할 수 있게 된다.

## 네트워크 아키텍처

### OSI 참조 모델 7계층

- 응용 계층
- 표현 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터링크 계층
- 물리 계층

### TCP/IP

- OSI를 대신하여 오늘날 가장 폭넓게 이용되고 있는 네트워크 아키텍처
- 네트워크 통신에 필요한 기능을 4개의 계층으로 나누어 생각한다.
- 응용 계층에서는 애플리케이션끼리 데이터를 주고받기 위한 규약, 즉 데이터 포맷이나 데이터의 송수신 순서 등을 규정하고 있다.
- 전송 계층, 인터넷 계층, 네트워크 인터페이스 계층은 이러한 환경에서 특정 애플리케이션간의 데이터를 올바르게 전달하기 위해 존재한다.

  - 응용 계층(HTTP)
  - 전송 계층 (TCP, UDP)
  - 인터넷 계층 (IP)
  - 네트워크 인터페이스 계층 (이더넷)

## 쿠키

- Set-Cookie : 서버에서 클라이언트로 쿠키 전달(헤더)
- Cookie : 클라이언트가 서버에서 받은 쿠기를 저장하고, HTTP 요청시 서버로 전달
- HTTP는 무상태 프로토콜이기 때문에 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
- 모든 요청에 쿠키 정보 자동 포함

#### 단점

- 쿠키 정보는 항상 서버에 전송됨
- 따라서 네트워크 트래픽 추가 유발할 수 있다.
- 최소한의 정보만 사용한다. (세션 id, 인증 토큰)
- 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 참고
- 보안에 민감한 데이터는 저장하면 안됨

## 세션

- 서버측에서 관리한다.
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여한다.
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다.
- 즉, 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다.

### 쿠키와 세션의 차이점

- 라이프사이클

#### 쿠키

- 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다.
- 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다.

#### 세션

- 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.

## 캐시

- 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빠르다.
- 빠른 사용자 경험

### 검층 헤더 추가

- 데이터가 마지막에 수정된 시간을 헤더(Last-Modified)에 추가한다.
- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
- 304 Not Modified + 헤더 메타 정보만 응답(바디 X)

#### 단점

- 1초 미만 단위로 캐시 조정이 불가능
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우<br>
  ex) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

### ETag(Entity Tag)

- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기
- 캐시 제어 로직을 서버에서 완전히 관리<br>
  ex) 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신

### no-cache vs must-revalidate

![image](https://user-images.githubusercontent.com/68647194/105606160-0ea75380-5ddb-11eb-8118-0a66ba87c619.png)

![image](https://user-images.githubusercontent.com/68647194/105606174-1ff06000-5ddb-11eb-805e-e5600e703f4d.png)

## REST API

- 웹의 장점을 최대한 활용할 수 있는 아키텍쳐
- HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하고 있다.
- REST의 기본 원칙을 성실히 지킨 서비스 디자인을 **RESTful** 이라고 한다.
- 규칙 2가지
  1. URI는 정보의 자원을 표현해야 한다.
  2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현한다.

💡 참고 자료

- 손으로 익히며 배우는 네트워크 첫걸음
- 인프런 강의 자료(모든 개발자를 위한 HTTP 웹 기본 지식)
