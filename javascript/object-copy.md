## 얕은 복사와 깊은 복사 이해하기

### 데이터 타입의 종류

- 기본형(원시형)
    - 숫자, 문자열, 불리언, null, undefined, 심볼
- 참조형
    - 객체

### 메모리와 데이터

- 1바이트는 8비트 (256개의 값을 표현할 수 있다)
- C/C++, 자바 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 정해놓았다.
- 메모리의 용량이 과거보다 월등히 커진 상황에서 등장한 자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로워졌다. 
- **숫자의 경우** 정수형인지 부동소수형인지를 구분하지 않고 **64비트, 즉 8바이트**를 확보한다. 
- 덕분에 개발자가 형변환을 걱정해야 하는 상황이 훨씬 덜 발생하게 되었다. 

### 식별자와 변수

- 변수 : 변할 수 있는 무언가, 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇
- 식별자 : 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명

### 변수 영역, 데이터 영역

- **변수와 데이터를 별도의 공간에 나누어 저장한다.**
- 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다. 
- 만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 확보된 공간을 변환된 데이터 크게에 맞게 늘리는 작업이 선행돼야한다. 
- 중간에 있는 데이터를 늘려야 하는 상황이라면? 해당 공간보다 뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업을 해야 한다. 
- 결국 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.

### 변수와 상수, 불변성

- 변수와 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리이다. 
- 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역 메모리**이다. 

### 불변값 예시

- 문자
    - 변수 a에 문자열 `abc`를 할당했다가 뒤에 `def`를 추가하면 기존의 `abc`가 `abcdef`로 바뀌는 것이 아니라 새로운 문자열 `abcdef`를 만들어 그 주소를 변수 a에 저장한다. 
- 숫자
     - 변수 b의 값을 5에서 7로 바꾸고자 한다면, 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 기존에 저장했던 7을 찾아서 있으면 재활용하고, 없으면 새로 만들어서 b에 저장한다.
- 문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다. 
- 변경은 새로 만드는 동작을 통해서만 이뤄진다. 
- 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다. 

### 가변값 예시

- 기본형 데이터와의 차이는 **객체의 변수(프로퍼티)영역**이 별도로 존재한다.
- 데이터 영역에 저장된 **값**은 모두 불변값이다. 
- 그러나 **변수**에는 다른 값을 얼마든지 대입할 수 있다. (이 부분 때문에 흔히 참조형 데이터는 불변하지 않다, 가변값이다라고 한다)
    - 데이터 영역에 저장한 주소는 변경 가능!

### 가비지 컬렉터

- 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다.

### 변수 복사 비교

- 기본형 데이터와 참조형 데이터의 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생한다. 

> 기본형 데이터 복사

```javascript
var a = 10; 
var b = a;
````

1. 변수 영역에 빈 공간(**@1001**)을 확보하고, 그 주소의 이름을 a로 지정한다. 
2. 데이터 영역에서 숫자 10을 검색한다. 없으면 임의로 **@5001**에 저장하고, 이 주소를 **@1001**에 저장한다. 
3. 변수 영역에 빈 공간(**@1002**)을 확보하고, 그 주소의 이름을 b로 지정한다. 
4. a라는 식별자를 가진 주소를 찾는다. 
5. **@1001**에 저장된 값인 **@5001**을 들고 **@1002**에 값으로 대입한다. 

> 참조형 데이터 복사

```javascript
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1
```

1. 변수 영역에 빈 공간(**@1003**)을 확보하고, 그 주소의 이름을 obj1으로 지정한다. 
2. 데이터 영역의 빈 공간(**@5002**)을 확보하고, 별도의 변수 영역 **@7103~**을 확보해 그 주소를 저장한다.
3. **@7103**에는 식별자 c를, **@7104**에는 식별자 d를 입혁한 다음, c에 대입할 값 10을 데이터 영역에서 검색한다. **@5001**에 이미 저장돼 있으므로 이 주소를 **@7103**에 연결하고, 문자열인 'ddd'는 데이터 영역의 빈 공간에 새로 만들어서 **@7104**에 연결한다.

> 변수 복사 이후 값 변경 결과 비교1

```javascript
var a = 10; 
var b = a; 
var obj1 = { c: 10, d: 'ddd'};
var obj2 = obj1; 

b = 15; // 1
obj2.c = 20; // 2
````

1. 데이터 영역에 아직 15가 없으므로 새로은 공간 **@5004**에 저장하고, 그 주소를 든 채로 변수 영역에서 식별자가 b인 주소를 찾아 변경한다.
2. 데이터 영역에 아직 20이 없으므로 새로운 공간 **@5005**에 저장하고, 그 주소를 든 채로 변수 영역에서 obj2를 찾고, obj2의 값인 @5002가 가리키는 변수 영역에서 다시 c를 찾아 그곳에 **@5005**를 대입한다. 

- **변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태이다.**

```javascript
a !== b
obj1 === obj2
```

> 변수 복사 이후 값 변경 결과 비교2

```javascript
obj2 = { c: 20, d: 'ddd' }; // 객체 자체를 변경했을 때
```

- 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장한다.
- 객체에 대한 변경임에도 값이 달라졌다. 
- 즉, 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다. 

## 불변 객체 만드는 방법

1. 

```javascript
var user = { 
    name: 'Jaenam',
    gender: 'male'
};

var changeName = function (user, newName) {
    // 새로운 객체를 반환한다. 
    return {
        name: newName,
        gender: user.gender;
    }
}

var user2 = changeName(user, 'Jung');

if(user !== user2) {
    console.log('유저 정보가 변경되었습니다.') // 유저 정보가 변경되었습니다.
}
```

- 문제점 : 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 사용자가 입력하는 수고가 늘어날 것이다. 

2. 

```javascript
var copyObject = function (target) {
    var result = {}; 
    for(var prop in target) {
        result[prop] = target[prop];
    }

    return result; 
}
```

- 문제점 : 얕은 복사만 수행한다. 

> 어떤 객체를 복사할 때 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다. 이 과정을 첨조형 데이터가 있을 때마다 재귀적으로 수행해야만 비로서 깊은 복사가 된다. 

### 깊은 복사 방법

```javascript
var copyObjectDeep = function(target) {
    var result = {}; 

    if(typeof target === 'object' && typeof target !== null) {
        for(var prop in target) {
            result[prop] = copyObjectDeep(target[prop]);
        }    
    }
    else {
        result = target; 
    }

    return result; 
}
```

💡 참고 자료

- [도서] 코어 자바스크립트 




